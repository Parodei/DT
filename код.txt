1.	#include <vcl.h> // директивы препроцессора
2.	#pragma hdrstop // директивы препроцессора
3.	#include <math.h> // директивы препроцессора
4.	#include <stdio.h > // директивы препроцессора
5.	#include "LoadEstimate.h" // директивы препроцессора
6.	//---------------------------------------------------------------------------
7.	TMathLib my; // создание класса
8.	//---------------------------------------------------------------------------
9.	double Ms[3];
10.	double Om_max=628;
11.	double Lmax=0.08;
12.	double Jdm=4.77e-5;
13.	//---------------------------------------------------------------------------
14.	double J[9] = { 0.1, 0, 0, 
15.	                0, 0.3, 0,
16.	                0, 0, 0.5 }; // тензор инерции
17.	double Jinv[9] = { 10, 0, 0,
18.	                   0, 10/3, 0,
19.	                   0, 0, 2 };
20.	//---------------------------------------------------------------------------
21.	void RightPart(double t, double *x, double *dx) { // функция правых частей
22.	  double w_q[4]= {0, x[4], x[5], x[6]}; // кватернион из омеги
23.	  double qp[4]; // промежуточный кватернион
24.	  my.quatmul(x, w_q, qp); //умножения кватерниона x на w_q, результат qp
25.	  my.smpy(qp, 0.5, qp, 4); // умножение вектора qp размерности 4 на число 0.5 (т.е поэлементно) результат записывается в qp
26.	  my.mcpy(qp, dx, 4// копирует 4 элемента массива qp в массив dx
27.	  double Jom[3], K[3], Sk[3];
28.	  double HKa[3];
29.	  my.mprd(J, &x[4], Jom, 3, 3, 1); // умножает матрицу J, представленную в виде одномерного массива, на матрицу &x[4] так же представленную виде массива. 
30.	  for (int i=0;i<3;i++) {
31.	   HKa[i]=Jom[i]+Jdm*x[7+i];
32.	  }
33.	  my.mvec(1., &x[4], HKa, K); //векторное произведения векторов x[4] и HKa (если первый параметр 1 то в первые 3 элемента вектора K
34.	  my.msub(Ms,K,Sk,3); // вычитает поэлементно массивы Ms и K размерности 3(ед число) и записывает результат в Sk
35.	  my.mprd(Jinv,Sk,&dx[4],3,3,1); // умножает матрицу Jinv, представленную в виде одномерного массива, на матрицу Sk так же представленную виде массива
36.	  double Om[3];
37.	  my.smpy(Ms, 1./Jdm, &dx[7],3); // умножение вектора Ms размерности 3 на число (1/Jdm) (т.е поэлементно) результат записывается в &dx[7]
38.	 }
39.	//---------------------------------------------------------------------------
40.	#pragma argsused // директивы препроцессора
41.	int main(int argc, char* argv[]) { // точка входа
42.	 double x[10]={0.3626884, 0.6019084, 0.1543355, -0.694509, -2e-5, 0, -1e-4, 0,0,0}; // первые 4 кватернионы
43.	 double t=0,tk=100, h=0.001;
44.	 double xk[10];
45.	 double q[4];
46.	 double qp[4];
47.	 if (my.LoadDLL() == false) // проверка подключения библиотеки
48.	 { return -1;my.Init();} // с помощью этой функции создается внутри библиотеки объект класса
49.	 int sh=10;
50.	 FILE *f = fopen("result.txt","w"); // открытие файла 
51.	 while (t<tk)
52.	 {
53.	  my.RK4(RightPart, t, x, xk, 10, h); // делает один шаг интегрирования методом рунге кутты 4 порядка для функции RightPart
54.	  my.mcpy(xk,x,10); // копирует 10 элементов массива xk в массив x
55.	  my.quatnorm(x); // нормирования кватерниона
56.	  for (int i=0;i<3;i++) {
57.	     if (fabs(x[i+7])>Om_max)
58.	     {
59.	      x[i+7]=Om_max*x[i+7]/fabs(x[i+7]);
60.	      Ms[i]=0;
61.	     }
62.	  }
63.	  if (sh % 10 ==0) {
64.	   fprintf(f,"%lf %lf %lf %lf %lf %lf %lf %lf\n", t, x[0], x[1], x[2], x[3], x[4]*57.29, x[5]*57.29, x[6]*57.29);
65.	   for (int i=0;i<3;i++) {
66.	     Ms[i]=-0.15*(fabs(x[0])/x[0])*x[i+1]-0.3*x[i+4];
67.	    }
68.	   for (int i=0; i<3;i++)
69.	   {                                                         
70.	    if(fabs(Ms[i])>Lmax) {
71.	     Ms[i]=Lmax*Ms[i]/fabs(Ms[i]);
72.	    }
73.	   }
74.	  }
75.	  sh+=1; // счётчик шагов
76.	  t+=h; // время плюс шаг интегрирования
77.	 }
78.	 fclose(f); // закрытия файла
79.	 my.CloseLib(); // удаление класса, созданного функцией init
80.	 }
81.	//---------------------------------------------------------------------------
